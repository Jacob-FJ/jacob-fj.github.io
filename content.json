{"pages":[{"title":"","text":"","link":"/categories/index.html"},{"title":"","text":"","link":"/tags/index.html"}],"posts":[{"title":"Mysql基础","text":"基本概念DB 数据库(database)：存在数据的仓库，保存了一系列有组织的数据。 DBMS 数据库管理系统(Database Management System)：数据库是通过DBMS创建和操作的数据容器 常见的数据库管理系统：MySQL, Oracle, DB2, SqlServer 分为两类： 基于共享文件系统的DBMS Access 只需要安装一端 基于客户机——服务器（C/S架构）的DBMS 如MySQL, Oracle, SqlServer 需要安装客户端和服务端 SQL 结构化查询语言(Structure Query Language)：专门用来与数据库通信的语言 不是某个特定数据库供应商的专有语言，几乎所有的DBMS都支持SQL 数据库特点 数据存在表中，表再放在库中 一个数据库可以有多个表，每个表都有一个名字用来标识自己。表名具有唯一性 表具有一些特性，这此特性定义了数据在表中如何存储 表由列组成，也称为字段，所有的表都是由一个或多个列组成的 表中的数据按行存储 MySQL 服务启动与停止 Method 1 此电脑 -&gt; 管理 -&gt; 服务和应用程序 -&gt; 服务 -&gt; 找到mysql服务名称，右键启动或关闭 Method 2 命令行（以管理员身份打开） 关闭net stop mysqlfj(服务名) 启动net start mysqlfj(服务名) Mysql 服务端的登录和退出 Method 1 命令行（管理员身份）： mysql [-h(主机) localhost -P(端口号) 3306] -u root -p(密码)(密码可直接跟在后面或者回车后再输入，跟在后面不能有空格) 在命令行环境中exit或Ctrl + C退出服务 Method 2 通过mysql自带的客户端，但只限于root用户 MySQL常见命令 查看当前所有的数据库：show databases ; 打开指定的库：use 库名 ; 查看当前库的所有表：show tables ; 查看其它库的所有表：show tables from 库名 ; 创建一个表 1234create table 表名( 列名1 列类型, 列名2 列类型， ...); 查看表的结构：desc 表名 查看服务器的版本 Method 1， 在mysql服务端内：select version() ; Method 2, 在dos中mysql --version或mysql -V MySQL语法规范 不区分大小写，但建议关键字大写，表名、列名小写 每条命令用分号结尾 每条命令根据需要，可以进行缩进和换行 注释 单行注释 # 注释文字 -- 注释文字 多行注释 /* 注释文字 */ DQL语言 DQL ：Data query language 基础查询 语法 12select 查询列表from 表名 ; 特点 查询列表可以是：表中的字段、常量、表达式、函数 查询的结果是一个虚拟的表格，不是真实存在的 着重号(``) 当关键字和字段名冲突时，用着重号表明这个是字段名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#1、查询单个字段SELECT last_name FROM employees ;#2、查询表中的多个字段SELECT last_name, salary, email FROM employees ;#3、查询表中的所有字段# Method 1:SELECT * FROM employees ;# Method 2:(在表的栏位中，对需要的字段双击)SELECT `employee_id`, `first_name`, `last_name`, `email`, `phone_number`, `job_id`, `salary`, `commission_pct`, `manager_id`, `department_id`, `hiredate` FROM employees ;#4、查询常量值SELECT 100;SELECT 'John';#5、查询表达式SELECT 188*98;#6、查询函数SELECT VERSION();#7、起别名/*1）便于理解2）如果要查询的字段有重名的情况，使用别名可以区分开来*/#Method 1--使用ASSELECT 100 % 98 AS 结果;SELECT last_name AS 姓, first_name AS 名 FROM employees;#Method 2--省略AS,中间用一个空格SELECT last_name 姓, first_name 名 FROM employees;##案例： 查询salary，显示结果为out put(别名的中间有空格)SELECT salary AS &quot;out put&quot; FROM employees;#8、去重--DISTINCT##案例：查询员工表中涉及到的所有的部门编号SELECT DISTINCT department_id FROM employees;#9、+号的作用/*mysql中的+号：只能当作数学运算符select 100+90; 两个操作数都为数值型，则做加法运算select '123'+90; 其中一个是字符型，试图将字符型数据转换成数值型， 如果转换成功，则继续做加法运算 （这里返回213） select 'john'+90; 如果无法转换，则将字符型数据当作0，再相加（这里返回90）select '12ab56c'+90; 只要前面能转换出一个数，就会把这个数与后面数字相加， 这里字符型数据只能转换出12出来，所以结果是102 select null+90; 只要一方为null，结果一定也是null*/##案例：查询员工名和姓连接成一个字段，并显示为 姓名-- 下面这个示例是错误的，mysql语句中+号不能连接字段，只能当作数学运算符SELECT last_name + first_name AS 姓名 FROM employees ;-- 下面是正确的拼接方式，concat， concat自己不会添加空格，可自己指定SELECT CONCAT(last_name,' ', first_name) AS 姓名 FROM employees;# 10、ifnull函数/*IFNULL(expr1,expr2):如果expr1是null,返回expr2,否则返回expr1自己的值*/SELECT IFNULL(commission_pct,0) FROM employees; 条件查询 语法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140select 查询列表from 表名where 筛选条件 ;- 执行顺序 1. `from`：先判断有没有这个表，如果有先定位这个表 2. `where`：根据筛选条件（与表行一样长的True/False向量）选出合适的记录 3. `select`：最后从符合筛选条件的记录中，拿出需要的字段- 根据筛选条件的不同，可以进行分类 1. 按条件表达式筛选 - 条件运算符：&lt;, &gt;, &lt;&gt;/!=, &lt;=, &gt;= 2. 按逻辑表达式筛选 - 逻辑运算符：`&amp;&amp;, ||, !`，但mysql自己标准的是`and, or, not` 3. 模糊查询 - `like`, `between and/ not between and`, `in`, `is null/ is not null` ```sql #一、按条件表达式筛选 #案例1：查询工资&gt;12000的员工信息 SELECT * FROM employees WHERE salary &gt; 12000; #案例2：查询部门编号不等于90号的员工名和部门编号 SELECT last_name, department_id FROM employees WHERE department_id &lt;&gt; 90; #二、按逻辑表达式筛选 #案例1：查询工资在10000到20000之间的员工名、工资以及资金 SELECT last_name, salary, commission_pct FROM employees WHERE salary &gt;= 10000 AND salary &lt;= 20000; #案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息 SELECT * FROM employees WHERE NOT(department_id &gt;= 90 AND department_id &lt;= 110) OR salary &gt; 15000; #三、模糊查询 /* like 特点： 1、一般和通配符搭配使用 %：任意多个字符（包括0） _：任意单个字符 2、也可以对数值型数据使用，相当于对数值转成字符后再模型匹配 between and/ not between and 使用between and 可以提高语句的简洁度 包含临界值 两个临界值不可以颠倒顺序，between aa and bb等价于 &gt;= aa and &lt;=bb in 含义：用于判断某字段的值是否属于in列表中的某一项 特点： 使用in相比于一系列or提高语句的简洁度 in列表中的值类型必须一致或兼容 不支持通配符 is null/ is not null =, !=, &lt;&gt;不能用于判断null值 is null/ is not null可以用于判断null */ #1、like #案例1：查询员工名中包含字符a的员工信息 SELECT * FROM employees WHERE last_name LIKE &quot;%a%&quot;; #案例2：查询员工名中第三个字符为n，第五个字符为l的员工名和工资 SELECT last_name, salary FROM employees WHERE last_name LIKE '__n_l%'; #案例3：查询员工名中第二个字符为_的员工名（转义字符） # 方法一：默认可以用\\转义 SELECT last_name FROM employees WHERE last_name LIKE '_\\_%'; # 方法二：自定义转义字符 SELECT last_name FROM employees WHERE last_name LIKE '_$_%' ESCAPE '$'; #案例4：查询部门编号是由1开头的三位数的部门编号 （匹配数值型数据） SELECT DISTINCT department_id FROM employees WHERE department_id LIKE '1__'; # 2、between and（左闭右闭） #案例1：查询员工编号在100到120之间的所有员工信息 SELECT * FROM employees WHERE employee_id BETWEEN 100 AND 120; # 3、in #案例1：查询员工的工种编号是 IP_PROG,AD_VP, AD_PRES中的一个的员工名和工种编号 SELECT last_name, job_id FROM employees WHERE job_id IN ('IP_PROG','AD_VP','AD_PRES'); # 4、is null/ is not null #案例1：查询没有资金的员工名和资金率 SELECT last_name, commission_pct FROM employees WHERE commission_pct IS NULL; #案例2：查询有资金的员工名和资金率 SELECT last_name, commission_pct FROM employees WHERE commission_pct IS NOT NULL; ## ##安全等于&lt;=&gt; ## /* 可以用于判断null值或正常=可以判断的类型 */ #案例1：查询没有资金的员工名和资金率 SELECT last_name, commission_pct FROM employees WHERE commission_pct &lt;=&gt; NULL; #案例2：查询工资为12000的员工信息 SELECT * FROM employees WHERE salary &lt;=&gt; 12000; 排序查询 语法 123456789select 查询列表from 表名[where 筛选条件]order by 排序列表[asc | desc]#案例：查询员工信息，要求工资从高到低排序SELECT *FROM employeesORDER BY salary DESC; 执行顺序： from where select order by：因为在select后面，故在select中的别名可以用来真的排序 特点 asc代表升序，默认选项，desc降序 order by子句中可以支持单个字段、多个字段、表达式、函数、别名 order by子句一般是放在查询语句的最后面，limit子句除外 123456789101112131415161718192021222324252627282930313233#案例1：查询员工信息，要求工资从高到低排序SELECT *FROM employeesORDER BY salary DESC;#案例2【添加筛选条件】：查询部门编号&gt;=90的员工信息，按入职时间的先后进行排序SELECT *FROM employeesWHERE department_id &gt;= 90ORDER BY hiredate ASC;#案例3【按表达式排序】：按年薪的高低显示员工的信息和年薪SELECT *, salary*12*(1+IFNULL(commission_pct,0)) 年薪FROM employeesORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;#案例4【按别名排序】：按年薪的高低显示员工的信息和年薪SELECT *, salary*12*(1+IFNULL(commission_pct,0)) 年薪FROM employeesORDER BY 年薪 DESC;#案例5【按函数排序】：按姓名的长度降序显示员工的姓名的工资SELECT last_name, LENGTH(last_name) 姓名长度FROM employeesORDER BY LENGTH(last_name) DESC;#案例6【多个字段组合排序】：查询员工信息，要求先按工资排序，再按员工编号排序SELECT *FROM employeesORDER BY salary ASC, employee_id DESC; 常见函数 功能 概念：将一组逻辑、操作语句封装，对外暴露方法名 好处：隐藏实现细节，提高代码的重用性 调用：select 函数名() [from 表名] 特点： 函数名 函数功能 分类 单行函数：concat(), length(), ifnull() 字符函数 数学函数 日期函数 其他函数 流程控制函数 分组函数 做统计使用，又称为统计函数、聚合函数、组函数 单行函数字符函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#一、字符函数#1、length 获取参数值的字节（不是字符）个数，英文1个，中文在utf8下3个SELECT LENGTH('John'); -- 4SELECT LENGTH('张'); -- 3SELECT LENGTH('张美丽abc'); -- 12#2、concat 拼接字符串SELECT CONCAT(last_name, '_', first_name) 姓名FROM employees;#3、upper , lower 转大小写SELECT UPPER('john'); -- JOHNSELECT LOWER('JOHN'); -- john#示例：将姓变大写，名变小写，然后拼接SELECT CONCAT(UPPER(last_name),LOWER(first_name)) 姓名FROM employees;#4、substr(substring)-- ！！sql语言中索引从1开始-- substr(str, start),从start开始截到最后SELECT SUBSTR('李莫愁爱上了陆展元', 6) out_put; -- 了陆展元SELECT SUBSTR('李莫愁爱上了陆展元', 7) out_put; -- 陆展元-- substr(str, start， len),从start开始截len个字符长度（是字符）SELECT SUBSTR('李莫愁爱上了陆展元', 1,3) out_put; -- 李莫愁#案例：姓名中首字符大写，其它字符小写然后用_拼接，显示出来SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),'_',SUBSTR(last_name,2)) out_putFROM employees;#5、instr 返回子字符串在原字符串的第一次起始索引，如果不存在返回0SELECT INSTR('杨不悔爱上了殷六侠','殷六侠') AS out_put;-- 7#6、trim去除前后空格或指定的符号SELECT TRIM(' 张翠山 ') AS output, LENGTH(TRIM(' 张翠山 ')) AS len;#下面的要注意区分，trim只会整数倍的去除from前的指定字符串SELECT TRIM('a' FROM 'aaaa张aa翠aaa山aaaaa') AS out_put; -- 张aa翠aaa山SELECT TRIM('aa' FROM 'aaaa张aa翠aaa山aaaaa') AS out_put; -- 张aa翠aaa山a#7、lpad -用指定的字符实现左填充到指定长度SELECT LPAD('殷素素',10,'*') AS out_put; -- *******殷素素SELECT LPAD('殷素素',2,'*') AS out_put; -- 殷素（填充字符长度小于原字符串长度）#8、rpad -用指定的字符实现左填充到指定长度SELECT RPAD('殷素素',10,'ab') AS out_put; -- 殷素素abababaSELECT RPAD('殷素素',2,'ab') AS out_put; -- 殷素(也是从左边开始截断）#9、replace 替换SELECT REPLACE('张无忌周芷若爱上了周芷若','周芷若','赵敏') AS output; -- 张无忌赵敏爱上了赵敏 数学函数1234567891011121314151617181920212223242526272829303132333435#二、数学函数##1、round 四舍五入SELECT ROUND(1.65); -- 2SELECT ROUND(1.45); -- 1SELECT ROUND(-1.65); -- -2SELECT ROUND(-1.45); -- -1SELECT ROUND(1.567,2); -- 1.57##2、ceil 向上取整SELECT CEIL(1.0022); -- 2SELECT CEIL(-1.999); -- -1##3、floor 向下取整SELECT FLOOR(1.0022); -- 1SELECT FLOOR(-1.999); -- -2##4、truncate 截断SELECT TRUNCATE(1.567,2); -- 1.56##5、mod取余/*mod(a,b) = a - (a//b)*bmod(-10,-3) = (-10) - (-10//(-3))*(-3) = -1*/SELECT MOD(-10,-3); -- -1SELECT MOD(10,3); -- 1SELECT 10 % 3; -- 1SELECT MOD(10,-3); -- 1SELECT MOD(-10,3); -- -1 日期函数 格式符 功能 %Y 四位的年份 %y 两位的年份 %m 月份（01, 02, 03,…..,10,11,12） %c 月份(1, 2, 3,…., 10, 11, 12) %d 日(01, 02, …) %H 小时（24小时制） %h 小时（12小时制） %i 分钟(00,01,….,59) %s 秒（00,01,…, 59) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#三、日期函数##1、now 返回当前系统日期和时间SELECT NOW(); -- 2023-07-05 15:53:05##2、curdate 仅返回当前系统日期SELECT CURDATE(); -- 2023-07-05##3、curtime 仅返回当前系统时间SELECT CURTIME(); -- 15:55:12##4、获取指定的部分，年，月，日，小时，分钟，秒SELECT YEAR(NOW()); -- 2023SELECT MONTH('20100102'); -- 1SELECT MONTHNAME('2023-07-05'); -- JulySELECT YEAR(hiredate) 年FROM employees;##5、str_to_date 字符串转日期SELECT STR_TO_DATE('2023|06|06','%Y|%m|%d'); -- 2023-06-06#案例：查询入职日期为1992-4-3的员工信息SELECT *FROM employeesWHERE hiredate = '1992-04-03';#案例：假设客户端输入'4-3 1992'，查询这个入职日期的员工信息SELECT *FROM employeesWHERE hiredate = STR_TO_DATE('4-3 1992','%c-%d %Y');##6、date_format 将日期转为字符SELECT DATE_FORMAT('2023-06-06','%Y年%m月%d日');-- 2023年06月06日SELECT DATE_FORMAT(NOW(),'%Y年%m月%d日');-- 2023年07月05日#案例：查询有奖金的员工名和入职日期(xx月/xx日 xxxx年）SELECT last_name, DATE_FORMAT(hiredate, '%m月/%d日 %Y年')FROM employeesWHERE commission_pct IS NOT NULL;##7、datediff SELECT DATEDIFF('2023-07-01','2023-06-25'); # 6SELECT DATEDIFF(NOW(), '2000-01-01'); # 8586#案例1：查询最晚的入职时间和最早的入职时间差多少天SELECT DATEDIFF(MAX(hiredate), MIN(hiredate)) FROM employees; # 8753#案例2：查询最 早 的入职时间和 最 晚 的入职时间差多少天SELECT DATEDIFF(MIN(hiredate), MAX(hiredate)) FROM employees; # -8753 其他函数1234567#四、其他函数SELECT VERSION();SELECT DATABASE();SELECT USER(); 流程控制函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#五、流程控制函数##1、if函数：if-else效果SELECT IF(10 &gt; 5, '大', '小'); -- 大#案例：判断员工是否有奖金SELECT last_name, commission_pct, IF(commission_pct IS NULL, '没资金','有资金') '备注'FROM employees;##2、case函数#使用一：switch case的效果/*C/JAVA中switch(变量或表达式){ case 常量1: 语句1; break; ... default: 语句n;}mysql中case 要判断的字段或表达式when 常量1 then 要显示的值1[或语句1;(只有是语句的时候才需要加分号）]when 常量2 then 要显示的值2[或语句2;]...else 要显示的值n或[语句n;]end*//*案例：查询员工的工资，要求 部门号=30，显示的工资为1.1倍 部门号=40，显示的工资为1.2倍 部门号=50，显示的工资为1.3倍 其他部门，显示原工资*/SELECT salary 旧工资, department_id, CASE department_id WHEN 30 THEN salary * 1.1 WHEN 40 THEN salary * 1.2 WHEN 50 THEN salary * 1.3 ELSE salary END AS 新工资FROM employees;#使用二：类似多重if/*C/JAVA中if(条件){ 语句1;} else if(条件){ 语句2;}...else{ 语句n;}mysql中case when 条件 then 值[或者语句;]when 条件 then 值[或者语句;]...else 值[或语句n;]end*//*案例：查询员工的新工资情况 如果工资&gt;20000，显示A级别 如果工资&gt;15000, 显示B级别 如果工资&gt;10000, 显示C级别 否则，显示D级别*/SELECT salary, CASE WHEN salary &gt;20000 THEN 'A' WHEN salary &gt; 15000 THEN 'B' WHEN salary &gt; 10000 THEN 'C' ELSE 'D' END AS 工资级别FROM employees; 聚合函数 功能 用作统计使用，又称为聚合函数或统计函数或组函数 分类 sum：求和 avg：平均值 max：求最大值 min：求最小值 count：计算个数 特点 sum, avg ：一般用于处理数值型 min, max, count：可以处理任意数据类型 都忽略null值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#分组函数/*分类：sumavgmaxmincount*/##1、简单的使用SELECT SUM(salary) FROM employees;SELECT AVG(salary) FROM employees;SELECT MIN(salary) FROM employees;SELECT MAX(salary) FROM employees;SELECT COUNT(salary) FROM employees;SELECT SUM(salary) 总和, AVG(salary) 平均, MIN(salary) 最低 FROM employees;##2、参数支持哪些类型/*sum, avg：只支持数值型mim, max, count：可以支持任何类型，数值、字符、时间*/##3、是否忽略null值# 都忽略null值##4、和distinct搭配SELECT SUM(DISTINCT salary) FROM employees; -- 对去重之后的salary求和SELECT COUNT(DISTINCT salary) FROM employees;-- 57, 有57个级别的工资水平##5、count函数的详细介绍SELECT COUNT(salary) FROM employees;SELECT COUNT(*) FROM employees; -- 统计表的总行数，主键一定不存在null -- 只要有一行不为空，就会count上SELECT COUNT(1) FROM employees; -- 也计算了总行数，相当于创建了一列1再计数/*效率：mysam(5.5版本前）存储引擎下，count(*)效率高innodb（5.5版本后）存储引擎下，count(*)和count(1)效率差不多，比count(字段）要高*/##6、和分组函数一同查询的字段有限制/*和分组函数一同查询的字段要求是group by后的字段*/-- 下面的语句无意义，报错SELECT AVG(salary), employee_id FROM employees; 分组查询 语法 12345select 分组函数， 列（要求出现在group by 的后面）from 表[where 筛选条件]group by 分组列表[order by 子句] 注意 查询列表必须特殊，要求是分组函数和group by后出现的字段 特点 分组查询中的筛选条件分为两类 分组前筛选：对原始表进行筛选——放在group by子句前——where子句 分组后筛选：对分组后的结果集进行筛选——放在group by子句后——having子句 分组函数做条件肯定在having子句中 能用分组前筛选的，尽量用where子句 group by 子句支持单个字段分组，多个字段分组（多个字段之间用逗号隔开，没有顺序要求），表达式或者函数（用的较少） 也可以添加排序，放在分组查询最后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#进阶5：分组查询#引入：查询每个部门的平均工资SELECT department_id, AVG(salary) AS department_avg_salary FROM employeesWHERE department_id IS NOT NULLGROUP BY department_idORDER BY department_avg_salary DESC;##### 简单的分组查询####案例1：查询每个工种的最高工资SELECT job_id,MAX(salary)FROM employeesGROUP BY job_id;#案例2：查询每个位置上的部门个数SELECT COUNT(*), location_idFROM departmentsGROUP BY location_id;##### 添加筛选条件####案例1：查询邮箱中包含a字符的，每个部门的平均工资SELECT AVG(salary), department_idFROM employeesWHERE email LIKE '%a%'GROUP BY department_id;#案例2：查询有资金的每个领导手下员工的最高工资SELECT MAX(salary), manager_idFROM employeesWHERE commission_pct IS NOT NULLGROUP BY manager_id;##### 添加复杂的筛选条件(分组后的筛选）###-- having可以调用select中的参量，where只能调用from表中的字段 #案例1：查询哪个部门的员工个数大于2SELECT department_id, COUNT(*)FROM employeesGROUP BY department_idHAVING COUNT(*) &gt; 2;#案例2：查询每个工种有资金的员工的最高工资&gt;12000的工种编号和最高工资SELECT job_id, MAX(salary)FROM employeesWHERE commission_pct IS NOT NULLGROUP BY job_idHAVING MAX(salary) &gt; 12000;#案例3：查询领导编号&gt;102的每个领导手下的员工最低工资&gt;5000的领导编号和最低工资SELECT manager_id, MIN(salary)FROM employeesWHERE manager_id&gt; 102GROUP BY manager_idHAVING MIN(salary) &gt; 5000;##### 按表达式或函数分组####案例：按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些SELECT COUNT(*) numbers, LENGTH(last_name) LEN_NameFROM employeesGROUP BY LENGTH(last_name)HAVING numbers &gt; 5;##### 按多外字段####案例：查询每个部门每个工种的员工的平均工资SELECT department_id, job_id, AVG(salary) mean_salaryFROM employeesGROUP BY department_id, job_id;##### 添加排序####案例：查询每个(非空）部门每个工种的员工的平均工资，并对平均工资大于10000的结果按平均工资逆序输出SELECT department_id, job_id, AVG(salary) mean_salaryFROM employeesWHERE department_id IS NOT NULLGROUP BY department_id, job_idHAVING mean_salary &gt; 10000ORDER BY mean_salary DESC; 连接查询 含义 又称多表查询，当查询的字段来自多个表时，需要涉及连接查询 笛卡尔乘积现象：表1有m行，表2有n行，结果有 m*n 行 产生原因：没有有效的连接条件 解决方法：添加有效的连接条件——在where子名中限定，注意不同字段相等要用属性方法标明来自哪个表 分类 按年代分类 SQL92标准：仅支持内连接 SQL99标准【推荐】：支持内边接+外连接（左外和右外)+交叉连接 按功能分类 内连接 等值连接 非等值连接 自连接 外连接 左外连接 右外连接 全外连接 交叉连接 SQL92 等值连接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111####### 一、SQL92标准########### （一）、等值连接#1、多表等值连接的结果为多表的交集部分#2、n表连接，至少需要n-1个连接条件#3、多表的顺序没有要求#4、一般需要为表起别名#5、可以搭配前面介绍的所有子句使用######案例1：查询女神名和对应的男神名SELECT `name`, boyNameFROM beauty, boysWHERE beauty.`boyfriend_id` = boys.`id`;#案例2：查询员工名和对应的部门名SELECT last_name, department_nameFROM employees, departmentsWHERE employees.`department_id` = departments.`department_id`;#### 1、为表起别名###/*- 提高语句的简洁度- 区分多处重名的字段- from子句对表起别名后，则查询的字段不能再用原来的表名来限定*/#案例：查询员工名，工种号，工种名SELECT last_name, e.job_id, job_title -- 有歧义的字段要标明来自哪个表FROM employees AS e, jobs AS jWHERE e.`job_id` = j.`job_id`;#### 2、两个表的顺序可以调换####案例：查询员工名，工种号，工种名SELECT last_name, j.job_id, job_title -- 有歧义的字段要标明来自哪个表FROM jobs AS j, employees AS eWHERE j.`job_id` = e.`job_id`;#### 3、添加筛选####案例1：查询有资金的员工名、部门名SELECT last_name, department_name, commission_pctFROM employees AS e, departments AS dWHERE e.`department_id` = d.`department_id` AND `commission_pct` IS NOT NULL; #案例2：查询城市名中第二个字符为o的部门名和城市名SELECT department_name, cityFROM departments AS d, locations AS lWHERE d.`location_id` = l.location_idAND city LIKE '_o%';#### 4、添加分组####案例1：查询每个城市的部门个数SELECT COUNT(*), cityFROM departments AS d , locations AS lWHERE d.`location_id` = l.`location_id`GROUP BY city;#案例2：查询有资金的每个部门的部门名和部门的领导编号和该部门的最低工资SELECT d.department_name, d.manager_id,MIN(salary)FROM employees AS e, departments AS dWHERE e.`department_id` = d.`department_id`AND commission_pct IS NOT NULLGROUP BY d.`manager_id`, d.`department_id`;#### 5、添加排序####案例：添加每个工种的工种名和员工的个数，并且按员工个数降序SELECT job_title, COUNT(*) AS numsFROM employees AS e, jobs AS jWHERE e.`job_id` = j.`job_id`GROUP BY job_titleORDER BY nums DESC;### # 6、三表连接####案例：查询员工名、部门名和所在的城市SELECT last_name, department_name, cityFROM employees AS e, departments AS d, locations AS lWHERE e.`department_id` = d.`department_id` AND d.`location_id` = l.`location_id`; 非等值连接123456789######（二）、非等徝连接######案例1：查询员工的工资和工资级别SELECT salary, grade_levelFROM employees AS e, job_grades AS gWHERE e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`; 自连接123456789###### （三）、自连接######案例：查询员工名和上级的名称SELECT e.employee_id, e.last_name, e.`manager_id`, m.last_nameFROM employees AS e, employees AS mWHERE e.`manager_id` = m.`employee_id`; SQL99 语法 12345678select 查询列表from 表1 别名【连接类型】 join 表2 别名 on 连接条件【where 筛选条件】【group by 分组】【having 筛选条件】【order by 排序列表】 分类 内连接：inner 外连接 左外left [outer] 右外right [outer] 全外full [outer] 交叉连接cross 内连接等值连接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869######（一）、内连接#####/*语法：slelect 查询列表from 表1 别名inner join 表2 别名on 连接条件分类：等值连接非等值连接自连接特点：1、可以添加排序、分组、筛选2、inner可以省略3、筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读4、inner join连接和SQL92语法中的等值连接效果一样，都是查询多表的交集*/####1、等值连接####案例1：查询员工名、部门名SELECT last_name, department_nameFROM employees AS eINNER JOIN departments AS dON e.`department_id` = d.`department_id`;#案例2【添加筛选】：查询名字中包含e的员工名和工种名SELECT last_name, job_titleFROM employees AS eINNER JOIN jobs AS jON e.`job_id` = j.`job_id`WHERE last_name LIKE '%e%';#案例3【添加分组、筛选】：查询部门个数&gt;3的城市名和部门个数 SELECT city, COUNT(*) dep_numsFROM departments AS dINNER JOIN locations AS lON d.`location_id` = l.`location_id`GROUP BY cityHAVING COUNT(*) &gt; 3;#案例4【排序】：查询员工个数&gt;3的部门名和员工个数，并按员工个数降序输出 SELECT department_name, COUNT(*) employ_numsFROM departments AS dINNER JOIN employees AS eON e.`department_id` = d.`department_id`GROUP BY department_nameHAVING COUNT(*) &gt; 3ORDER BY COUNT(*) DESC;#案例5【三表连接】：查询员工名、部门名，工种名，并按部门名降序SELECT last_name, department_name, job_titleFROM employees AS eINNER JOIN departments AS d ON e.`department_id` = d.`department_id`INNER JOIN jobs AS j ON e.`job_id` = j.`job_id`ORDER BY department_name DESC; 非等值连接1234567891011121314151617181920####2、非等值连接####案例：查询员工的工资级别SELECT salary, grade_levelFROM employees AS eINNER JOIN job_grades AS gON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`;#案例：查询不同工资级别的员工个数，并对员工个数大于20的工资级别和员工个数降序输出 SELECT grade_level, COUNT(*) employ_numsFROM employees AS eINNER JOIN job_grades AS gON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`GROUP BY grade_levelHAVING COUNT(*) &gt; 20ORDER BY COUNT(*) DESC; 自连接123456789101112131415161718####3、自连接####案例：查询员工的名字和其上级的名字SELECT e.last_name, m.last_nameFROM employees AS eINNER JOIN employees AS mON e.`manager_id` = m.`employee_id`;#案例：查询姓名中包含k的员工的名字和其上级的名字SELECT e.last_name, m.last_nameFROM employees AS eINNER JOIN employees AS mON e.`manager_id` = m.`employee_id`WHERE e.`last_name` LIKE '%a%'; 外连接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657######二、外连接#####/*应用场景： 用于查询一个表中有，另一个表中没有的记录特点：1、外连接的查询结果为主表中的所有记录， 如果从表中有和它匹配的，则显示匹配的值 如果从表中没有匹配的，则显示null 外连接查询结果 = 内连接结果 + 主表中有而从表中没有的记录2、左外连接，left join左边的是主表 右外连接, right join右边的是主表3、左外和右外交换两个表的顺序，结果一样4、全连接 = 内连接 + 表1中有但表2中没有的 + 表2中有但表1中没有的*/#引入：查询男朋友不在男神表的女神名#左外连接SELECT b.nameFROM beauty AS bLEFT OUTER JOIN boys AS boON b.`boyfriend_id` = bo.`id`WHERE bo.id IS NULL;#右外连接SELECT b.nameFROM boys AS boRIGHT OUTER JOIN beauty AS bON b.`boyfriend_id` = bo.`id`WHERE bo.id IS NULL;#案例1：查询哪个部门没有员工#左外SELECT d.*, employee_idFROM departments AS dLEFT OUTER JOIN employees AS eON d.`department_id` = e.`department_id`WHERE e.employee_id IS NULL;#右外SELECT d.*, employee_idFROM employees AS eRIGHT OUTER JOIN departments AS dON d.`department_id` = e.`department_id`WHERE e.employee_id IS NULL;#全外连接SELECT b.*, bo.*FROM beauty AS bFULL OUTER JOIN boys AS boON b.`boyfriend_id` = bo.id; 交叉连接123456789######三、交叉连接####### 笛卡尔乘积SELECT b.*, bo.*FROM beauty bCROSS JOIN boys bo; SQL92和SQL99 功能 SQL99支持较多 可读性 SQL99可读性更高 子查询 含义 出现在其它语句中的select语句，又称为子查询或内查询 外部的查询语句，称为主查询或外查询 分类 按子查询出现的位置 select 后面 仅支持标量子查询 from 后面 支持表子查询 where/having 后面 标量子查询 列子查询 行子查询 exists 后面（相关子查询） 表子查询 按结果集的行列数不同 标量子查询（结果集只有1行1列） 列子查询（结果集只有1列多行） 行子查询（结果集有1行多列，多行多列） 表子查询（结果集一般为多行多列 where\\having后面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155###### 一、where或having后面#####/*1、标量子查询（单行子查询）2、列子查询（多行子查询）3、行子查询（多列多行）特点：1、子查询都放在小括号内2、子查询一般放在条件的右侧3、标量子查询，一般搭配着单行操作符使用：&gt; &lt; &gt;= &lt;= = &lt;&gt; 列子查询，一般搭配着多行操作符使用：in, any/some, all 4、子查询优先于主查询*/####1、标量子查询####案例1：谁的工资比abel高SELECT last_name, salaryFROM employeesWHERE salary &gt; ( SELECT salary FROM employees WHERE last_name = 'abel');#案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id和工资SELECT last_name, job_id, salary FROM employees WHERE job_id = (SELECT job_id FROM employees WHERE employee_id = 141)AND salary &gt; (SELECT salary FROM employees WHERE employee_id = 143) ;#案例3：返回公司工资最少的员工的last_name, job_id, salarySELECT last_name, job_id, salaryFROM employeesWHERE salary = ( SELECT MIN(salary) FROM employees);#案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资SELECT department_id, MIN(salary)FROM employeesGROUP BY department_idHAVING MIN(salary) &gt; ( SELECT MIN(salary) FROM employees WHERE department_id = 50);#### 2、列子查询（多行子查询）####案例1：返回location_id 是1400或1700的部门中的所有员工姓名SELECT last_nameFROM employeesWHERE department_id IN ( SELECT department_id FROM departments WHERE `location_id` IN (1400,1700));SELECT last_name, d.location_idFROM employees AS eJOIN departments AS d ON e.`department_id` = d.`department_id`WHERE d.`location_id` IN (1400, 1700);#案例2：返回其它工种中比job_id为'IT_PROG'工种任一工资低的员工的# 员工号，姓名，job_id以及salarySELECT employee_id, last_name, job_id, salaryFROM employeesWHERE job_id &lt;&gt; 'IT_PROG'AND salary &lt; ANY ( SELECT DISTINCT salary FROM employees WHERE job_id = 'IT_PROG');-- 或者SELECT employee_id, last_name, job_id, salaryFROM employeesWHERE job_id &lt;&gt; 'IT_PROG'AND salary &lt; ( SELECT MAX(salary) FROM employees WHERE job_id = 'IT_PROG' ); #案例3：返回其它工种中比job_id为'IT_PROG'工种 所有 工资低的员工的# 员工号，姓名，job_id以及salarySELECT employee_id, last_name, job_id, salaryFROM employeesWHERE job_id &lt;&gt; 'IT_PROG'AND salary &lt; ALL ( SELECT DISTINCT salary FROM employees WHERE job_id = 'IT_PROG');-- 或者SELECT employee_id, last_name, job_id, salaryFROM employeesWHERE job_id &lt;&gt; 'IT_PROG'AND salary &lt; ( SELECT MIN(salary) FROM employees WHERE job_id = 'IT_PROG');#### 3、行子查询（结果集一行多列或多行多列）####案例：查询员工编号最小并且工资最高的员工信息-- 标量查询方法SELECT *FROM employeesWHERE employee_id = ( SELECT MIN(employee_id) FROM employees) AND salary = ( SELECT MAX(salary) FROM employees);-- 行子查询格式SELECT *FROM employeesWHERE (employee_id, salary) = ( SELECT MIN(employee_id), MAX(salary) FROM employees); select 后面123456789101112131415161718192021222324252627###### 二、select后面#####/*仅仅支持标量子查询，子查询结果只能1行1列*/#案例1：查询每个部门的员工个数SELECT d.*, ( SELECT COUNT(*) FROM employees AS e WHERE e.department_id = d.department_id) 员工个数FROM departments d;#案例2：查询员工号为102的部门名SELECT ( SELECT department_name FROM departments d INNER JOIN employees e ON d.department_id = e.department_id WHERE employee_id = 102) 部门名; from后面12345678910111213141516171819###### 三、from后面#####/*将子查询结果充当一张表，必需发起别名子查询中的select后如果有函数结果，对这个结果也要起别名，不然不好在主查询引用*/#案例：查询每个部门的平均工资和工资等级SELECT a.*, grade_levelFROM job_grades AS gINNER JOIN ( SELECT department_id, AVG(salary) avg_salary FROM employees GROUP BY department_id)AS a ON a.avg_salary BETWEEN g.`lowest_sal` AND g.`highest_sal`; exists后面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748###### 四、exists后面（相关子查询）#####/*语法： exists(完整的查询语句)结果： 如果查询语句不为空，返回1；否则返回0*/#案例1：查询有员工的部门名SELECT department_nameFROM departments dWHERE EXISTS( SELECT * FROM employees e WHERE d.`department_id` = e.`department_id`);-- 或者SELECT department_nameFROM departmentsWHERE department_id IN (SELECT DISTINCT department_id FROM employees)-- 或者SELECT DISTINCT department_nameFROM departments dINNER JOIN employees AS eON e.department_id = d.department_id;#案例2：查询没有女朋友的男神信息-- existsSELECT b.*FROM boys AS bWHERE NOT EXISTS( SELECT * FROM beauty be WHERE b.id = be.`boyfriend_id`);-- inSELECT b.*FROM boys AS bWHERE b.id NOT IN (SELECT DISTINCT boyfriend_id FROM beauty); 分页查询 应用场景 当要显示的数据，一页显示不全，需要分布提交sql请求 语法 1234567891011121314select 查询列表from 表名join type 表2on 连接条件where 筛选条件group by 分组字段 having 分组后的筛选条件order by 排序字段limit offset, size/*offset：要显示条目的起始索引，起始索引从0开始size：要显示的条目个数*/ 特点 limit语句放在查询语句的最后 执行顺序： from where group by having select order by limit 公式 要显示的页数是第page页, 每页的条目数size 123select 查询列表from 表limit size*(page-1), size 1234567891011121314151617181920212223#案例1：查询前5条员工信息SELECT *FROM employeesLIMIT 0, 5;-- 或者在Limit后只跟一个数，默认从索引0开始，数表示 sizeSELECT *FROM employeesLIMIT 5;#案例2：查询第11条到第25条SELECT *FROM employeesLIMIT 10, 15;#案例3：有奖金的员工信息，并且工资较高的前10名SELECT *FROM employeesWHERE commission_pct IS NOT NULLORDER BY salary DESCLIMIT 10; 联合查询 union联合，合并：将多条查询语句的结果合并成一个结果，相当于对两个查询结果进行纵向拼接，过程中需要自己保证列数和列含义一致 语法： 123456查询语句1union查询语句2union查询语句3... 应用场景 筛选条件过于复杂的情况下用于拆分 要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时 特点 要求多条查询语句的查询列数一致 要求多条查询语句的查询的每一列的类型和顺序一致（保证列的含义的相同） union关键字默认是去重的，如果使用union all可以包含重复项 1234567891011121314151617#引入：查询部门编号大于90或邮箱中包含a的员工信息SELECT *FROM employeesWHERE email LIKE '%a%' OR department_id &gt; 90;-- 联合查询SELECT * FROM employees WHERE email LIKE '%a%'UNIONSELECT * FROM employees WHERE department_id &gt; 90;#案例：查询中国用户中男性的信息，以及外国用户中的男性信息，返回在一张表中SELECT id, cname, csex FROM t_ca WHERE csex = '男'UNION ALLSELECT t_id, tName, tGender FROM t_ua WHERE tGender = 'male'; DML语言 DML : Data Manage Language 数据操作语言 插入：insert 修改：update 删除：delete 插入语句方式一（经典插入） 语法 12insert into 表名(列名1, 列名2,...)values(值1, 值2,...); 123456789101112131415161718192021222324#1、插入的值的类型要与列的类型一致或兼容INSERT INTO beauty(id, `name`, sex, borndate, phone, photo, boyfriend_id)VALUES(13,'唐艺昕','女','1990-04-23','18988888888',NULL,2);#2、不可以为null的列必须插入值，可以为null的列如何插入值？-- 方式一：写明nullINSERT INTO beauty(id, `name`, sex, borndate, phone, photo, boyfriend_id)VALUES(13,'唐艺昕','女','1990-04-23','18988888888',NULL,2);-- 方式二：在表的字段中不写出，values中也不写这个字段的值INSERT INTO beauty(id, `name`, sex, phone)VALUES(15,'娜扎','女','19988888888');#3、列的顺序可以调换，只要保证values中对应就可以INSERT INTO beauty(`name`, sex, id, phone)VALUES('蒋欣', '女', 16, '521');#4、列数和值的个数必须一致，即使是nullable的列，只要写了，一定要给值#5、可以省略列名，但默认是包含了所有列，而且列的顺序和表中列的顺序一致INSERT INTO beautyVALUES(18,'张飞','男',NULL,'119',NULL,NULL); 方式二 语法 12insert into 表名set 列名1=值1， 列名2=值2, ... 12INSERT INTO beautySET id = 19, NAME = '刘涛', phone = '999'; 两种方式对比 方式一支持一次插入多行，方式二不支持 1234INSERT INTO beautyVALUES(23,'唐艺昕1','女','1990-04-23','18988888888',NULL,2),(24,'唐艺昕2','女','1990-04-23','18988888888',NULL,2),(25,'唐艺昕3','女','1990-04-23','18988888888',NULL,2); 方式一支持子查询，方式二不支持 123456INSERT INTO beauty(id, NAME, phone)SELECT 26,'宋莤','123456';INSERT INTO beauty(id, NAME, phone)SELECT id, boyname, '654321'FROM boys WHERE id &lt; 3; 修改语句 语法 修改单表的记录 123update 表名set 列1=新值1, 列2=新值2, ...where 筛选条件; 修改多表的记录 123456789101112【sql92语法】update 表1 别名, 表2 别名set 列=值, ...where 连接条件and 筛选条件【sql99语法】update 表1 别名,inner|left|right join 表2 别名on 连接条件set 列=值, ...where 筛选条件; 1234567891011121314151617181920212223242526272829303132#1、修改单表的记录#案例1：修改beauty中姓唐的女神的电话为13899888899UPDATE beautySET phone = '13899888899'WHERE `name` LIKE '唐%';#案例2：修改boys表中id好友为2的名称为张飞，魅力值为10UPDATE boysSET boyName = '张飞', userCP = 10WHERE id = 2;#2、修改多表的记录#案例1：修改张无忌的女朋友的手机号114UPDATE beauty bINNER JOIN boys boON b.`boyfriend_id` = bo.`id`SET b.`phone` = '114'WHERE bo.`boyName` = '张无忌';#案例2：修改没有男朋友的女神的男朋友编号都为2号UPDATE beauty AS bLEFT JOIN boys AS boON b.`boyfriend_id` = bo.`id`SET b.`boyfriend_id` = 2WHERE bo.id IS NULL; 删除语句 语法 方式一：delete 1234567891011121314151617-- 1、单表的删除 delete from 表名where 筛选条件-- 2、多表的删除【sql92】delete 表1的别名,表2的别名from 表1 别名1, 表2 别名2where 连接条件and 筛选条件【sql99】delete 表1的别名,表2的别名from 表1 别名inner|left|right join 表2 别名on 连接条件where 筛选条件 方式二：truncate 1truncate table 表名; -- 直接删除整个表 12345678910111213141516171819202122232425262728293031#方式一：delete#1、单表的删除#案例1：删除手机号最后一位为9的女神信息DELETE FROM beautyWHERE phone LIKE '%9';#2、多表的删除#案例1：删除张无忌的女朋友信息DELETE bFROM beauty bINNER JOIN boys boON b.`boyfriend_id` = bo.`id`WHERE bo.`boyName` = '张无忌';#案例2：删除黄晓明的信息以及他女朋友的信息DELETE b, boFROM beauty bINNER JOIN boys boON b.`boyfriend_id` = bo.`id`WHERE bo.`boyName` = '黄晓明';#方式二：truncate语句 TRUNCATE TABLE boys; -- 将boys表的数据全部删除，但表仍是存在的，是不过是空表，truncate无法添加where筛选条件 delete 与truncate对比【面试题✨】 delete可以添加where条件，truncate不能加 truncate删除的效率要高一点点 假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点处开始；而truncate删除后，再插入数据，自增长列的值从1开始 truncate删除没有返回值，delete删除有返回值：返回几行受影响 truncate删除不能回滚，delete删除可以回滚 DDL语言 DDL : Data Define Language 数据定义语言：库和表的管理 库的管理：创建、修改、删除 表的管理：创建、修改、删除 创建：create 修改：alter 删除：drop 库的管理123456789101112131415161718192021222324252627282930313233343536373839####1、库的创建###/*语法：CREATE DATABASE 库名;CREATE DATABASE [IF NOT EXISTS] 库名;-- 如果库不存在则创建，如果存在则不创建且不报错*/#案例：创建库booksCREATE DATABASE IF NOT EXISTS books;####2、库的修改###/*-- 改库名，已经不能用了 rename database books to bookss;*/#更改库的字符集ALTER DATABASE books CHARACTER SET gbk;####3、库的删除###DROP DATABASE books;-- 下面的语句可以在不存在库的情况下不报错DROP DATABASE IF EXISTS books; 表的管理表的创建 语法 1234567create table 表名( 列名 列的类型【(列的长度) 列的约束】, 列名 列的类型【(列的长度) 列的约束】, 列名 列的类型【(列的长度) 列的约束】, ... 列名 列的类型【(列的长度) 列的约束】 ) 12345678910111213141516171819202122232425262728293031323334353637####1、表的创建###/*语法： create table if not exists 表名( 列名 列的类型【(列的长度) 列的约束】, 列名 列的类型【(列的长度) 列的约束】, 列名 列的类型【(列的长度) 列的约束】, ... 列名 列的类型【(列的长度) 列的约束】 )*/#案例1：创建book表CREATE TABLE IF NOT EXISTS book( id INT, -- 编号 bNname VARCHAR(20), -- 书名 price DOUBLE, -- 价格 authorid INT, -- 作者编号 publishDate DATETIME -- 出版日期);DESC book;#案例2：创建表authorCREATE TABLE IF NOT EXISTS author( id INT, au_name VARCHAR(20), nation VARCHAR(10));DESC author; 表的修改 语法 123alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;alter table 表名 rename to 新表名; 12345678910111213141516171819202122232425262728293031323334####2、表的修改#####（1）、修改列名#案例1：修改book表中publishDate为pubDateALTER TABLE book CHANGE COLUMN publishDate pubDate DATETIME;##（2）、修改列的类型或约束#案例1：修改book表pubdate的类型为timestampALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;##（3）、添加新列#案例1：给author表中新添加一列年薪ALTER TABLE author ADD COLUMN annual DOUBLE【first|after字段名 （默认添加在最后，fisrt:添加为第一个字段，after字段：添加在字段后 ）】;##（4）、删除列#案例1：删除author表的年薪列ALTER TABLE author DROP COLUMN annual;##（5）、修改表名#案例1：修改author表名为book_authorALTER TABLE author RENAME TO book_author; 表的删除123456789101112131415161718####3、表的删除####案例1：删除表book_authorDROP TABLE IF EXISTS book_author;SHOW TABLES; -- 查看当前库的所有表#新建库、表的通用写法DROP DATABASE IF EXISTS 旧库名;CREATE DATABASES 新库名;DROP TABLE IF EXISTS 旧表名;CREATE TABLE 新表名(); 表的复制12345678910111213141516171819202122232425262728293031323334353637####4、表的复制 ###INSERT INTO authorVALUES(1,'村上春树','日本'),(2,'莫言','中国'),(3,'冯唐','中国'),(4,'金庸','中国');#1、仅仅复制表的结构CREATE TABLE copy LIKE author;#2、同时复制表的结构和全部数据CREATE TABLE copy2SELECT * FROM author;#3、复制表的结构，但只有部分数据（部分列或者部分记录都行）添加筛选条件CREATE TABLE copy3SELECT id, au_name FROM author WHERE nation = '中国';#4、复制表的结构，但只是部分结构CREATE TABLE copy4SELECT id, au_nameFROM authorWHERE 1=2; -- 没有记录可以满足这个条件，故最终只复制了表结构, where 0;也行-- 下面的方法也行CREATE TABLE copy5SELECT id, au_nameFROM authorLIMIT 0,0; 常见的数据类型 常见的数据类型 数值型： 整形 小数 定点数 浮点数 字符型 较短的文本 char varchar 较长的文本 text blob(较长的二进制数据，如图片) 日期型 整型 整数类型 字节 范围 Tinyint 1 有符号：-128-127无符号：0-255 Smallint 2 有符号：-3276832767无符号：065535 Mdeiumint 3 有符号：-83886088388607无符号：01677215 Int, integer 4 有符号：-2147483648~2147483647无符号：0-4294967295 Bigint 8 - 分类 tinyint, smallint, mediumint ,int, bigint 特点 如果设置无符号还是有符号，默认是有符号；如果想设置无符号，需要添加unsigned关键字 如果插入的数值超过了类型的范围，会报out of range异常或直接报错(8.0版本)，并且插入临界值（对应超过的方向） 如果不设置长度，会有默认长度，长度代表了显示的最大宽度，如果表中的数值长度小于设定的长度，且在字段受关键字zerofill约束，则会在左边用0填充 123456789101112131415161718192021#1.如何设置无符号和有符号CREATE TABLE tab_int( t1 INT);INSERT INTO tab_intVALUES(-1),(2); -- 默认是有符号类型DROP TABLE IF EXISTS tab_int;CREATE TABLE tab_int( t1 INT(20), t2 INT UNSIGNED);INSERT INTO tab_intVALUES(-1,-2); # -2向下超过了数据的范围，会变成0INSERT INTO tab_intVALUES(999999999999,1); #999999999999向上超过了int的范围，设置的是临界值2147483647 小数 浮点型 float， 4字节 double， 8字节 定点型 DEC(M,D) / DECIMAL(M,D)， M+2字节， 相比于浮点型更精确 123456789101112131415161718192021222324252627282930313233343536373839404142/*分类： 1.浮点型 float(M,D) double(M,D) 2.定点型 dec(M,D) decimal(M,D) 特点： 1.M和D M：代表整数部位和小数部位的长度 D：小数部位的长度 Note：小数前的数值长度就固定在M-D了，如果超过范围，插入临界值 2.M和D都可以省略 如果是decimal，则M默认为10，D默认为0 如果是float和double，则会根据插入数值的精度来决定精度 3.定点型的精确度高，如果要求插入数值的精度较高如货币运算则用考虑使用 原则: 所选择的类型越简单越好，在不影响数据完整性前提下，所占内存越小越好*/#测试M和D的含义CREATE TABLE IF NOT EXISTS tab_float( f1 FLOAT(5,2), f2 DOUBLE(5,2), f3 DECIMAL(5,2));INSERT INTO tab_floatVALUES(123.45,123.45,123.45),(123.456,123.456,123.456),(1234.5,1234.5,1234.5);SELECT * FROM tab_float;DELETE FROM tab_float; 字符型 较短的文本： char(M)：M表示最大的字符数，下同。M可以省略，默认为1 varchar(M)：M不可以省略 区别：char表示固定长度（无论保存的值多少长度，内存空间一样大），varchar表示可变长度（根据实际数据开辟内存空间） 较长的文本 text blob 其它 binary和varbinary用于保存较短的二进制 enum用于保存枚举 set用于保存集合 1234567891011121314151617181920212223242526272829303132333435/* 写法 M的意思 特点 空间耗费 效率char char(M) 最大的字符数 固定长度的字符 比较耗费 高varchar varchar(M) 最大的字符数 可变长度的字符 比较节省 低*/#enum枚举类型CREATE TABLE tab_char( c1 ENUM('a','b','c'));-- c1字段只能输入a,b,c三类字符INSERT INTO tab_charVALUES('a'),('b'),('d'),('B'); -- 第三行记录是空值SELECT * FROM tab_char;#set类型CREATE TABLE IF NOT EXISTS tab_set( s1 SET('a','b','c','d'));INSERT INTO tab_set VALUES ('a');INSERT INTO tab_set VALUES ('a,b');INSERT INTO tab_set VALUES ('a,b,c');INSERT INTO tab_set VALUES ('a,b,c,d');INSERT INTO tab_set VALUES ('a,D,E'); -- e会忽视掉SELECT * FROM tab_set; 日期型 日期和时间 字节 最小值 最大值 date 4 1000-01-01 9999-12-31 datetime 8 1000-01-01 00:00:00 9999-12-31 23:59:59 timestamp 4 19700101080001 2038年的某个时刻 time 3 -838:59:59 838:59:59 year 1 1901 2155 datetime和timestamp比较 类型 字节 范围 时区等的影响 datetime 8 1000-1-1~9999-12-31 不受 timestamp 4 1970-2038 受 12345678CREATE TABLE tab_date( t1 DATETIME, t2 TIMESTAMP);INSERT INTO tab_date VALUES (NOW(), NOW());SELECT * FROM tab_date; 常见约束 含义：一种限制，用于限制表中的数据，为了最终保证表中数据的准确性和可靠性 分类：六大约束 not null：非空约束，用于保证该字段的值不能为空，比如姓名，学号 default：默认约束，用于保证该字段有默认值，比如性别 primary key：主键，用于保证该字段的值具有唯一性，并且非空 unique：唯一约束，用于保证该字段的值具有唯一性，可以为空，比如座位号 check：检查约束【mysql中不支持】，比如年龄、性别 foreign key：外键，用于限制两个表的关系，用于保证该字段的值来自于主表的关联列的值，在从表中添加外键约束，用于引用主表中某列的值，比如学生表的专业编号，员工表的部门编号、工种编号 添加约束的时机： 创建表时 修改表时（数据添加之前） 约束的添加分类 列级约束：六大约束语法上都支持，但外键约束没有效果 表级约束：除了非空和默认，其它都支持 create table test( c1 字段类型 列级约束, c2 字段类型, 表级约束 ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113- 🎉**主键和唯一的对比**： - | 类型 | 保证唯一性 | 是否允许 为空 | 一个表中可以有多少个 | 是否允许组合 | | ---- | ---------- | ------------- | -------------------- | ----------------------------------------- | | 主键 | 能 | 不允许 | 至多有1个 | 允许 `primary key(id, stuName)`，但不推荐 | | 唯一 | 能 | 允许 | 可以有多个 | 允许 `unique(seat,seat2)`，但不推荐 |- 🎉外键的特点 1. 要求在从表中设置外键关系 2. 从表的外键列的类型和主表的对应列（关联列）的类型一致或兼容，名称无要求 3. 要求主表中的关联列必须是一个key（一般是**主键**或唯一） 4. 插入数据时，先插入主表的数据，再插入从表的数据（如先给major表中有数据后，stuinfo中才可以对majorId进行填充值） 删除数据时，先删除从表，再删除主表（因为从表以外键的方式与主表的key锁定了### 创建表时添加约束| | 支持类型 | 可以起约束名 || -------- | -------------- | ---------------------------------------------------- || 列级约束 | 除了外键 | 不可以 || 表级约束 | 除了非空和默认 | 可以，但对主键无效（无论起什么名字，都会显示primary) |```mysql###########一、创建表时添加约束##############1、添加列级约束###/*语法： 直接在字段名和类型后面追加约束类型 只支持主键、非空、默认、唯一*/CREATE DATABASE students;USE students;CREATE TABLE major( -- 方便后面的外键约束 id INT PRIMARY KEY, majorName VARCHAR(20));CREATE TABLE stuinfo( id INT PRIMARY KEY, #主键 stuName VARCHAR(20) NOT NULL, #非空 gender CHAR(1) CHECK(gender IN ('男','女')), #检查 seat INT UNIQUE, #唯一 age INT DEFAULT 20, #默认 majorId INT REFERENCES major(id)#外键);DESC stuinfo;#查看表中的所有索引列，包括主键，外键，唯一SHOW INDEX FROM stuinfo;####2、添加表级约束###/*语法：在各个字段的最下面【constraint 自定义约束名 】约束类型(字段名)*/DROP TABLE IF EXISTS stuinfo;CREATE TABLE IF NOT EXISTS stuinfo( id INT, stuName VARCHAR(20), gender CHAR(1), seat INT, age INT, majorId INT, CONSTRAINT pk PRIMARY KEY(id),#主键，pk是自定义的约束名 CONSTRAINT uq UNIQUE(seat), #唯一 CONSTRAINT ck CHECK(gender = '男' OR gender = '女'), #检查 CONSTRAINT fk_stuinfo_mojor FOREIGN KEY(majorId) REFERENCES major(id)#外键);SHOW INDEX FROM stuinfo;#通用的写法：CREATE TABLE IF NOT EXISTS stuinfo( id INT PRIMARY KEY, stuName VARCHAR(20) NOT NULL, gender CHAR(1), age INT DEFAULT 18, seat INT UNIQUE, majorId INT, CONSTRAINT fk_stuinfo_mojor FOREIGN KEY(majorId) REFERENCES major(id)); 修改表时添加约束12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758###########二、修改表时添加约束##########/*语法：1、添加列级约束alter table 表名 modify column 字段名 字段类型 新约束;2、添加表级约束alter table 表名 add 【constraint 约束名】 约束类型(字段名)【外键的引用】*/DROP TABLE IF EXISTS stuinfo;CREATE TABLE IF NOT EXISTS stuinfo( id INT, stuName VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT);#1、添加非空约束#案例：对stuName列添加非空约束ALTER TABLE stuinfo MODIFY COLUMN stuName VARCHAR(20) NOT NULL;#2、添加默认约束ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;#3、添加主键约束-- 列级约束写法ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;-- 表级约束写法ALTER TABLE stuinfo ADD PRIMARY KEY(id); #这里ADD后面直接跟PRIMARY KEY不能有COLUMN#4、添加唯一约束-- 列级约束写法ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;-- 表级约束写法ALTER TABLE stuinfo ADD UNIQUE(seat);#5、添加外键约束-- 列级写法，语法可行，但没有实际运行改变-- 表级写法ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); 修改表时删除约束1234567891011121314151617181920212223242526###########三、修改表时删除约束###########1、删除非空约束ALTER TABLE stuinfo MODIFY COLUMN stuName VARCHAR(20);#2、删除默认约束ALTER TABLE stuinfo MODIFY COLUMN age INT;#3、删除主键ALTER TABLE stuinfo MODIFY COLUMN id INT;ALTER TABLE stuinfo DROP PRIMARY KEY;#4、删除唯一ALTER TABLE stuinfo DROP INDEX seat; -- seat 是SHOW INDEX FROM stuinfo中的Key_name列中的值#5、删除外键约束ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major; 标识列又称为自增长列，可以不用手动的插入值，系统提供默认的序列值 特点 标识列必须是一个键（主键，外键，唯一键） 一个表至多只能有一个标识列 标识列的数据类型只能是数值型（整型，小数） 标识列可以通过set auto_increment_increment = 123来设置步长 并通过手动插入首行记录来实现修改起始值的目的 创建表时设置标识列12345678910111213141516171819#一、创建表时设置标识列CREATE TABLE tab_identity( id INT PRIMARY KEY AUTO_INCREMENT, # AUTO_INCREMENT设定自增长 NAME VARCHAR(20));INSERT INTO tab_identity VALUES(NULL, 'john') -- 会自动赋值1,(NULL, 'john');-- 会自动赋值2INSERT INTO tab_identity(NAME) VALUES('lucy');#设置步长值（步长起始索引在mysql中无法更改,可以在插入第1行记录时手动设置起始索引）SHOW VARIABLES LIKE '%auto_increment%';SET auto_increment_increment = 3; 修改表时设置/删除标识列1234567891011121314#二、修改表时设置标识列DROP TABLE IF EXISTS tab_identity;CREATE TABLE tab_identity( id FLOAT, NAME VARCHAR(20));ALTER TABLE tab_identity MODIFY COLUMN id FLOAT UNIQUE AUTO_INCREMENT; #标识列必须是键#修改表时删除标识列ALTER TABLE tab_identity MODIFY COLUMN id FLOAT; #标识列必须是键 级联删除和级联置空1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677CREATE TABLE IF NOT EXISTS major( id INT PRIMARY KEY, majorName VARCHAR(20));CREATE TABLE IF NOT EXISTS stuinfo( id INT, stuName VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT);SHOW INDEX FROM major;SHOW INDEX FROM stuinfo;ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id);INSERT INTO majorVALUES(1,'java'),(2,'h5'),(3,'big data');INSERT INTO stuinfoSELECT 1,'john1','女', NULL, NULL, 1 UNION ALLSELECT 2,'john2','女', NULL, NULL, 1 UNION ALLSELECT 3,'john3','女', NULL, NULL, 2 UNION ALLSELECT 4,'john4','女', NULL, NULL, 2 UNION ALLSELECT 5,'john5','女', NULL, NULL, 1 UNION ALLSELECT 6,'john6','女', NULL, NULL, 3 UNION ALLSELECT 7,'john7','女', NULL, NULL, 3 UNION ALLSELECT 8,'john8','女', NULL, NULL, 1; #删除专业表的3号专业DELETE FROM major WHERE id = 3; -- 会报错，因为有外键引用##方式一：级联删除#外键的设置方式需要添加关键字 on delete cascade-- 先删除存在的外键ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;-- 设置可以级联删除的外键ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;-- 这种外键的设置，可以直接删除主表中的数据，并且从表中有引用主表被删除数据的记录也一并删除DELETE FROM major WHERE id = 3;SELECT * FROM major;SELECT * FROM stuinfo;##方式二：级联置空#外键的设置方式需要添加关键字 on delete set null-- 先删除存在的外键ALTER TABLE stuinfo DROP FOREIGN KEY fk_stu_major;-- 设置可以级联删除的外键ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;-- 这种外键的设置，可以直接删除主表中的数据，并且从表中有引用主表被删除数据的记录对应字段被设置为NULLDELETE FROM major WHERE id = 2;SELECT * FROM major;SELECT * FROM stuinfo; TCL语言 TCL : Transaction control language 事务控制语言 事务 定义： 事务由单独单元的一个或多个sql语句组成，在这个单元中，每个mysql语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条sql语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事务开始以前的状态；如果单元中的所有sql语句均执行成功，则事务被顺利执行。 场景：如转账，两个账号转出和转入要么都能成功，要么都不成功，不能只转出成功，转入不成功 存储引擎 概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中 通过show engines：来查看mysql支持的存储引擎，默认是innodb 在mysql中用的最多的存储引擎有：innodb, myisam, memory等。其中innodb支持事务，而myisam, memory等不支持事务 :star2: 事务的ACID（acid）特性 原子性(Atomicity) 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性(Consistency) 事务必须使数据库从一个一致性状态变换到另一个一致性状态 如：对于银行账户余额的库，如只允许转账操作，那么完成一个转账事务后，总的金额数会和事务前总的金额数一样 隔离性(Isolation) 事务的隔离性是指一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相干扰（需要受设置的隔离级别影响） 持久性(Durability) 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其它操作和数据库故障不应该对其有任何影响 事务的创建 隐式事务：事务没有明显的开启和结束的标记 任意一个insert/update/delete语句都会被当作一个事务 SHOW VARIABLES LIKE '%autocommit%'; 可以查看自动提交事务是否是开启的 显示事务：事务具有明显的开启和结束的标记 前提：必须先设置自动提交功能为禁用set autocommit = 0;，需要注意禁用自动提交只对当前对话（查询 ）有效 语法： 1234567891011121314#步骤1：开启事务SET autocommit = 0;START TRANSACTION; -- 可选#步骤2：编写事务中的sql语句(select insert update delete 查、增、改、删)语句1;语句2;语句3;...#步骤3：结束事务（要么是commit，要么是rollback，在服务器端无法根据是否成功来由程序自己选择）COMMIT; -- 提交事务ROLLBACK; -- 回滚事务 演示事务的使用步骤 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#演示事务的使用步骤DROP TABLE IF EXISTS account;CREATE TABLE IF NOT EXISTS account( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20), balance DOUBLE);INSERT INTO account(username, balance)VALUES('张无忌',1000), ('赵敏',1000);## 开启事务SET autocommit = 0;START TRANSACTION;## 编写一组事务的语句UPDATE account SET balance = 500 WHERE username = '张无忌';UPDATE account SET balance = 1500 WHERE username = '赵敏';## 结束事务COMMIT;ROLLBACK;/*在有commit或者rollback前，事务的处理相当于只是暂时存储在内存中，并没有更改数据库中的具体数据，当遇到commit时，事务具体发生，更改数据，当遇到rollback时，相当于事务的处理从内存中删除，没有具体对数据库的数据操作。*/#演示事务对delete和truncate的处理的区别SET autocommit = 0;START TRANSACTION;DELETE FROM account;ROLLBACK; -- 顺利回滚SET autocommit = 0;START TRANSACTION;TRUNCATE TABLE account;ROLLBACK; -- 无法回滚#演示savepoint的使用SET autocommit = 0;START TRANSACTION;DELETE FROM account WHERE id = 1;SAVEPOINT a; #设置保存点DELETE FROM account WHERE id = 2;ROLLBACK TO a;#回滚到保存点 数据库的隔离级别 对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题： 脏读 对于两个事务T1，T2，T1读取了已经被T2更新但还没有被提交的字段，之后，若T2回滚，T1读取的内容就是临时且无效的 不可重复读 对于两个事务T1，T2，T1读取了一个字段，然后T2更新了该字段，之后， T1再次读取同一个字段，值就不同了 幻读 对于两个事务T1，T2，T1读取了一个字段，然后T2在该表中插入了一些新的行。之后 ，如果T1再次读取同一个表，就会多出几行 数据库事务的隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题 一个事务与其他事务隔离的程度称为隔离级别，数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱 数据库提供的4种事务隔离级别 隔离级别 描述 READ UNCOMMITTED(读未提交数据) 允许事务读取未被其他事务提交的变更，脏读、不可重复读和幻读的问题都会出现 READ COMMITTED(读已提交数据) 只允许事务读取已经被其他事务提交的变更，可以避免脏读，但不可重复读和幻读问题仍然可能出现 REPEATABLE READ(可重复读) 确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新，可以避免脏读和不可重复读，但幻读的问题仍然存在 SERIALIZABLE(串行化) 确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作，所有并发问题都可以避免，但性能十分低下 oracle支持的2种事务隔离级别：READ COMMITED，SERIALIZABLE，默认的是READ COMMITED mysql支持4种事务隔离级别，默认的是REPEATABLE READ 每启动一个mysql程序，就会获得一个单独的数据库连接，每个数据库连接都有一个全局变量@@tx_isolation，表示当前的事务隔离级别 查看当前的隔离级别 1select @@tx_isolation; 设置当前mysql连接的隔离级别 1set session transaction isolation level read uncommitted; 设置数据库系统的全局的隔离级别 1set global transaction isolation level read committed; 视图视图 含义：虚拟表，和普通表一样使用。行和列的数据来自定义视图的查询中使用的表，并且是在使用时动态生成的，只保存了sql逻辑，不保存查询结果（相当于对一段可以查询出表的语句段进行封装） 应用场景： 多个地方用到同样的查询结果 该查询结果使用的sql语句较复杂 12345678910#案例：查询姓张的学生名和专业名CREATE VIEW v1ASSELECT stuname, majornameFROM stuinfo sINNER JOIN major mON s.majorid = m.id;SELECT * FROM v1 WHERE stuname LIKE '张%'; 创建视图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#一、创建视图/*语法：create view 视图名as查询语句;*/USE myemployees;#案例1：查询姓名中包含a字符的员工名、部门名和工种信息-- 创建视图CREATE VIEW myv1ASSELECT last_name, department_name, job_titleFROM employees eINNER JOIN departments d ON e.department_id = d.department_idINNER JOIN jobs j ON j.job_id = e.job_id;-- 使用视图SELECT * FROM myv1 WHERE last_name LIKE '%a%';#案例2：查询各部门的平均工资级别-- 创建视图CREATE VIEW myv2ASSELECT AVG(salary) ag, department_idFROM employeesGROUP BY department_id;-- 查询级别SELECT myv2.ag, g.grade_levelFROM myv2INNER JOIN job_grades gON myv2.ag BETWEEN g.`lowest_sal` AND g.`highest_sal`;#案例3：查询平均工资最低的部门信息SELECT * FROM myv2 ORDER BY ag LIMIT 1;#案例4：查询平均工资最低的部门名和工资CREATE VIEW myv3ASSELECT * FROM myv2 ORDER BY ag LIMIT 1;SELECT d.*, m.agFROM myv3 mINNER JOIN departments dON m.`department_id` = d.`department_id`; 视图的修改 1234567891011121314151617181920212223242526#二、修改视图#方式一：/*create or replace view 视图名as查询语句;*/#案例：将myv3视图更改为不同工种的平均工资CREATE OR REPLACE VIEW myv3AS SELECT AVG(salary), job_idFROM employeesGROUP BY job_id;#方式二：/*alter view 视图名as查询语句;*/ALTER VIEW myv3AS SELECT * FROM employees; 视图的查看和删除1234567891011121314151617181920#三、视图的查看和修改/*语法：drop view 视图名1，视图名2,....;*/DROP VIEW myv1, myv2, myv3;#四、查看视图CREATE VIEW myv3AS SELECT * FROM employees;#查看视图DESC myv3;show create view 视图名; 视图的更新 视图保存的是sql语句的逻辑，是原表数据经过查询后的映射，对视图的更新实际上是对原表的更改，然后因为是对原表的映射，最终好像是实现了对视图的更新修改 以下类型的视图是不能更新的 包含以下关键字的sql语句：分组函数，distinct，group by， having，union，union all 常量视图 select中包含子查询 join from一个不能更新的视图 where子名的子查询引用了from子句中的表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#五、视图的更新CREATE OR REPLACE VIEW myv1AS SELECT last_name, emailFROM employees;SELECT * FROM myv1;#1、插入INSERT INTO myv1 VALUES ('张飞2','zf@qq.com');SELECT * FROM myv1; -- 新记录在myv1视图中SELECT * FROM employees; -- 新记录也在原表中存在，除last_name和email外其余为null/*由于employees表的employee_id是主键和标识列，可以自己赋值，若不是自增长列那么新记录是无法插入到视图中的，因为在employees表中这条记录也无法插入注意：视图中的字段皆是原表中有的字段，如果视图中有原表中没有的字段如年薪，则无法插入包含年薪的新记录*/#2、修改UPDATE myv1 SET last_name = '张无忌' WHERE last_name = '张飞';SELECT * FROM myv1;SELECT * FROM employees;#3、删除DELETE FROM myv1 WHERE last_name = '张无忌'; -- 视图和原表都删除了SELECT * FROM myv1;SELECT * FROM employees;##以下类型的视图是不能更新的#1、 包含以下关键字的sql语句：分组函数，distinct，group by， having，union，union allDROP VIEW IF EXISTS myv1;CREATE OR REPLACE VIEW myv1ASSELECT MAX(salary) m, department_idFROM employeesGROUP BY department_id;SELECT * FROM myv1;#更新UPDATE myv1 SET m = 9000 WHERE department_id = 10; -- 更新失败#2、 常量视图CREATE OR REPLACE VIEW myv2AS SELECT 'john' NAME;SELECT * FROM myv2;#更新UPDATE myv2 SET NAME = 'lucy'; -- 更新失败#3、 select中包含子查询CREATE OR REPLACE VIEW myv3AS SELECT (SELECT MAX(salary) FROM employees) 最高工资;SELECT * FROM myv3;#更新UPDATE myv3 SET 最高工资= 10000; -- 更新失败#4、 joinCREATE OR REPLACE VIEW myv4ASSELECT last_name, department_nameFROM employees AS eJOIN departments AS dON e.department_id = d.department_id;SELECT * FROM myv4;#更新UPDATE myv4 SET last_name = '张飞' WHERE last_name = 'Whalen'; -- 修改可以成功INSERT INTO myv4 VALUES('陈真','xxxx'); -- 无法插入新值#5、from一个不能更新的视图CREATE OR REPLACE VIEW myv5ASSELECT * FROM myv3;SELECT * FROM myv5;#更新UPDATE myv5 SET 最高工资= 100000; -- 更新失败#6、 where子句的子查询引用了from子句中的表CREATE OR REPLACE VIEW myv6ASSELECT last_name, email, salaryFROM employeesWHERE employee_id IN ( SELECT manager_id FROM employees WHERE manager_id IS NOT NULL);SELECT * FROM myv6;#更新UPDATE myv6 SET salary = 10000 WHERE last_name = 'K_ing'; -- 更新失败 视图和表的对比 创建语法的关键字 是否实际占用物理空间 使用 视图 create view 没有为数据占用空间，只是占用了保存sql逻辑需要的空间 增、删、改，一般不能用；通常只用来查 表 creae table 有为数据占用空间 增、删、改、查 变量 分类 系统变量 全局变量 会话变量 自定义变量 用户变量 局部变量 系统变量 变量由系统提供，不是用户定义的，属于服务器层面 语法 查看所有的系统变量 12345678#显示所有系统变量show variables;#显示全局变量show global variables;#显示会话变量show session variables; 查看满足条件的部分系统变量 1show global|[session] variables like '%char%'; 查看指定的某个系统变量的值 123456-- 会话变量select @@系统变量名; select @@session.系统变量名;select @@global.系统变量名; -- 全局变量 为某个系统变量赋值 12345#方式一set global|[session] 系统变量名 = 值;#方式二set @@global|[session].系统变量名 = 值; 如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认是session 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#一、全局变量/*作用域： 服务器每次启动将为所有的全局变量赋初始值， 针对于所有的会话（连接）有效，但不能跨重启（即即使修改了全局变量的值，在下一次服务器重启后， 变量的值会自动回到系统默认的值）*/##1、查看所有的全局变量SHOW GLOBAL VARIABLES;##2、查看部分的全局变量SHOW GLOBAL VARIABLES LIKE '%char%';##3、查看指定的全局变量的值SELECT @@global.autocommit;SELECT @@gloabl.tx_isolation;##4、为某个指定的全局变量赋值-- 方式一；SET @@global.autocommit = 0;-- 方式二：SET GLOBAL autocommit = 1;#二、会话变量/*作用域： 仅仅针对于当前会话（连接）有效*/#1、查看所有的会话变量SHOW VARIABLES;SHOW SESSION VARIABLES;#2、查看部分的会话变量SHOW VARIABLES LIKE '%char%';SHOW SESSION VARIABLES LIKE '%char%';#3、查看指定的某个会话变量SELECT @@tx_isolation;SELECT @@session.tx_isolation;#4、为某个会话变量赋值-- 方式一：SET @@session.tx_isolation = 'read-uncommitted';SET @@tx_isolation = 'read-uncommitted';-- 方式二：SET SESSION tx_isolation = 'read-committed'; 自定义变量 变量是用户定义的，不是由系统提供的 使用步骤： 声明 赋值 使用 查看 比较 运算 … 分类 用户变量 作用域：针对于当前会话（连接）有效，同于会话变量的作用域 应用在任何地方，也就是begin end里面或外面 局部变量 作用域：仅仅在定义它的begin end中有效 应用在begin end中的第一名话 对比 作用域 定义和使用的位置 语法 用户变量 当前的会话 会话中的任何地方 必须加@符号，不用限定类型 局部变量 begin end中 只能在begin end中，且为第一句话 一般不用加@符号，需要限定类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#1、用户变量/*作用域：针对于当前会话（连接）有效，同于会话变量的作用域*/##1.声明并初始化赋值的操作符 =或 :=-- 以下是三种写法SET @用户变量名 = 值;SET @用户变量名 := 值;SELECT @用户变量名 := 值;#案例：声明并初始化SET @name = 'john';SET @name = 100;SET @cnt = 1;##2.赋值（更新用户变量的值）方式一：通过 SET 或 SELECT SET @用户变量名 = 值;SET @用户变量名 := 值;SELECT @用户变量名 := 值;方式二：通过 SELECT INTOSELECT 字段 INTO @变量名FROM 表名; -- 相当于一个查询语句的结果赋值给这个变量，但查询结果需要是标量#案例：赋值SELECT COUNT(*) INTO @cntFROM employees;##3.使用（查看用户变量的值）SELECT @用户变量名#案例：查看SELECT @cnt;#2、局部变量/*作用域：仅仅在定义它的begin end中有效应用在begin end中的第一句话*/##1.声明DECLARE 变量名 类型; -- 仅声明，没有初始化DECLARE 变量名 类型 DEFAULT 值; -- 声明的时候同时初始化##2.赋值方式一：通过 SET 或 SELECT SET 局部变量名 = 值;SET 局部变量名 := 值;SELECT @局部变量名 := 值;方式二：通过 SELECT INTOSELECT 字段 INTO 局部变量名FROM 名;##3.使用SELECT 局部变量名#案例：声明两个变量并赋初始值，求和，并打印#1.用户变量SET @m = 1;SET @n = 2;SET @sum = @m + @n;SELECT @sum;#2.局部变量-- 下面因为没有在begin end中使用，会语法报错DECLARE m INT DEFAULT 1;DECLARE n INT DEFAULT 2;DECLARE SUM INT;SET SUM = m + n;SELECT SUM; 存储过程和函数 存储过程和函数：类似于java中的方法 好处 提高代码的重用性 简化操作 存储过程 含义：一组预先编译好的sql语句的集合，理解成批处理语句 好处 提高代码的重用性 简化操作 减少了编译次数，并且减少了和数据库服务器的连接次数，提高了效率 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#一、创建语法-- 语法：CREATE PROCEDURE 存储过程名(参数列表)BEGIN 存储过程体END注意：1、参数列表包含三部分 参数的模式 参数名 参数类型举例：IN stuname VARCHAR(20)参数模型：IN：该参数可以作为输入，也就是说该参数需要调用方传入值OUT：该参数可以作为输出，也就是说该参数可以作为返回值INOUT：该参数既可以作为输入，也可以作为输出，也就是说该参数既需要传入值，又可以返回值2、如果存储过程体仅仅只有一句话，BEGIN END 可以省略 存储过程体中的每条SQL语句的结尾要求必须加分号 存储过程的结尾可以使用 DELIMITER 重新设置 语法： DELIMITER 结束标记 -- 一旦设置完成后，后面的语法都要以这个符号为结束标记了 如： DELIMITER $#二、调用语法语法: CALL 存储过程名(实参列表) 结束标记 ########## 创建和调用 ################## #1.空参列表##案例：插入到admin表中五条记录SELECT * FROM admin;#以下都要去命令行，即sql服务器中运行-- 先设置结束标记符DELIMITER $CREATE PROCEDURE myp1()BEGIN INSERT INTO admin(username, `password`) VALUES('john1','0000') ,('lily','0000') ,('rose','0000') ,('jack','0000') ,('tom','0000');END $ -- 最开始设置的结束标记符#调用CALL myp1()$#2、创建带in模式参数的存储过程#案例1：创建存储过程实现，根据女神名，查询对应的男神信息CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))BEGIN SELECT bo.* FROM boys bo RIGHT JOIN beauty b ON bo.id = b.boyfriend_id WHERE b.name = beautyName;END $#调用CALL myp2('柳岩')$-- 如果有遇上字符问题，可以执行下面的命令SET NAMES gbk$ -- $是因为更改过结束标记符#案例2：创建存储过程实现，用户是否登录成功CREATE PROCEDURE myp3(IN username VARCHAR(20), IN PASSWORD VARCHAR(20))BEGIN DECLARE result VARCHAR(20) DEFAULT ''; #声明并初始化局部变量 SELECT IF(COUNT(*)=0,'登录失败','登录成功') INTO result #局部变量赋值 FROM admin WHERE admin.`username` = username AND admin.`password` = PASSWORD; SELECT result; #局部变量使用END $#调用CALL myp3('张飞','8888')$#3、创建带out模式的存储过程#案例1：根据女神名，返回对应的男神名CREATE PROCEDURE myp5(IN beautyName VARCHAR(20), OUT boyName VARCHAR(20))BEGIN SELECT bo.boyName INTO boyName FROM boys bo INNER JOIN beauty b ON bo.id = b.boyfriend_id WHERE b.name = beautyName;END $#调用CALL myp5('王语嫣',@bName)$SELECT @bName$#案例2【两个out】：根据女神名，返回对应男神名和男神魅力值CREATE PROCEDURE myp6(IN beautyName VARCHAR(20), OUT boyName VARCHAR(20), OUT userCP INT)BEGIN SELECT bo.boyName, bo.userCP INTO boyName,userCP FROM boys bo INNER JOIN beauty b ON bo.id = b.boyfriend_id WHERE b.name = beautyName;END $CALL myp6('岳灵珊',@bName, @usercp)$SELECT @bName,@usercp$#4、创建带inout模式参数的存储过程#案例1：传入a,b，将a,b翻倍后返回CREATE PROCEDURE myp8(INOUT a INT, INOUT b INT)BEGIN SET a = a*2; SET b = b*2;END $SET @m = 10$SET @n = 20$CALL myp8(@m, @n)$SELECT @m, @n$###################################################################################三、删除存储过程语法：DROP PROCEDURE 存储过程名 -- 一次只能删除一个DROP PROCEDURE myp1;DROP PROCEDURE myp2, myp3; #报错###################################################################################四、查看存储过程的信息/结构 DESC myp6;#报错，这种方法不行SHOW CREATE PROCEDURE myp6; #可行 函数 含义：一组预先编译好的sql语句的集合，理解成批处理语句 好处 提高代码的重用性 简化操作 减少了编译次数，并且减少了和数据库服务器的连接次数，提高了效率 与存储过程的区别 存储过程：可以有0个返回，也可有多个返回， 适合做批量的插入、批量的更新 函数：有且仅有1个返回，适合做处理数据后返回一个结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#一、创建语法CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型BEGIN 函数体END/*注意：1.参数列表包含两个部分: 参数名 参数类型2.函数体：必须要有return 语句，如果没有会报错如果return没有放在函数体最后，这样不会报错，但不建议...return 值;3.当函数体中只有一句话时，begin end可以省略4.使用delimiter语句设置结束标记*/#二、调用语法SELECT 函数名(参数列表)###-------###创建和调用演示###-------------####1、无参数，有返回#案例：返回公司的加工个数DELIMITER $CREATE FUNCTION myf1() RETURNS INTBEGIN DECLARE c INT DEFAULT 0; #定义变量 SELECT COUNT(*) INTO c #赋值 FROM employees; RETURN c;END$SELECT myf1()$#2、有参，有返回#案例1：根据员工名，返回他的工资CREATE FUNCTION myf2(empname VARCHAR(20)) RETURNS DOUBLEBEGIN SET @sal = 0;#定义一个用户变量 SELECT salary INTO @sal FROM employees WHERE last_name = empname; RETURN @sal;END $SELECT myf2('kochhar')$#案例2：根据部门名，返回该部门的平均工资CREATE FUNCTION myf3(deptname VARCHAR(20)) RETURNS DOUBLEBEGIN DECLARE sal DOUBLE; SELECT AVG(salary) INTO sal FROM employees e INNER JOIN departments d ON e.department_id = d.department_id WHERE d.department_name = deptname; RETURN sal;END $SELECT myf3('IT')$#------------------------##三、查看函数SHOW CREATE FUNCTION 函数名;SHOW CREATE FUNCTION myf3;#四、删除函数DROP FUNCTION 函数名;DROP FUNCTION myf3;SELECT * FROM departments; 流程控制结构 分类 顺序结构：程序从上往下依次执行 分支结构：程序从两条或多条路径中选择一条执行 循环结构：程序在满足一定条件的基础上，重复执行一段代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#一、分支结构 #1、if函数功能：实现简单的分支语法：SELECT IF(表达式1,表达式2,表达式3);执行顺序：如果表达式1成立，则IF函数返回表达式2值，否则返回表达式3的值应用：任何地方#========================================================#2、case结构情况1：类似java中的switch语句，一般用于实现等值判断语法： CASE 变量|表达式|字段 WHEN 取值1 THEN 返回值|操作语句1 WHEN 取值2 THEN 返回值|操作语句2 ... ELSE 默认返回值|操作语句 END情况2：类似java中的多重IF语句，一般用于实现区间判断语法： CASE WHEN 要判断的条件1 THEN 返回值|操作语句1 WHEN 要判断的条件2 THEN 返回值|操作语句2 ... ELSE 默认返回值|操作语句 END 特点：1.可以作为表达式，嵌套在其他语句中使用，可以放在任何在方，BEGIN END中或外面 可以作为独立的语句去使用，只能放在BEGIN END中:/*情况1：类似java中的switch语句，一般用于实现等值判断语法： CASE 变量|表达式|字段 WHEN 取值1 THEN 操作语句1; WHEN 取值2 THEN 操作语句2; ... ELSE 默认操作语句; END CASE;情况2：类似java中的多重IF语句，一般用于实现区间判断语法： CASE WHEN 要判断的条件1 THEN 操作语句1; WHEN 要判断的条件2 THEN 操作语句2; ... ELSE 默认操作语句; END CASE;*/2.如果WHEN中的值满足或条件成立，则执行对应的THEN后面的语句，并且结束CASE如果都不满足，则执行ELSE中的语句或值3.ELSE可以省略，如果所有的WHEN判断都不满足且ELSE省略，则返回NULL#案例## 创建存储过程，根据传入的成绩，来显示等级，比如传入的成绩：## 90-100：A; 80-90:B; 60-80:C; 其它：DDELIMITER $CREATE PROCEDURE test_case(IN score INT)BEGIN CASE WHEN score &gt;= 90 AND score &lt;= 100 THEN SELECT 'A'; WHEN score &gt;= 80 THEN SELECT 'B'; WHEN score &gt;= 60 THEN SELECT 'C'; ELSE SELECT 'D'; END CASE;END $CALL test_case(95) $#========================================================#3、if结构功能：实现多重分支语法;IF 条件1 THEN 语句1;ELSEIF 条件2 THEN 语句2;ELSEIF 条件3 THEN 语句3;...【ELSE 语句n;】END IF;应用场合：只能在BEGIN END中#案例1:## 创建存储过程，根据传入的成绩，返回等级，比如传入的成绩：## 90-100：A; 80-90:B; 60-80:C; 其它：DCREATE FUNCTION test_if(score INT) RETURNS CHARBEGIN IF score &gt;= 90 AND score &lt;= 100 THEN RETURN 'A'; ELSEIF score &gt;= 80 THEN RETURN 'B'; ELSEIF score &gt;= 60 THEN RETURN 'C'; ELSE RETURN 'D'; END IF;END$SELECT test_if(85)$#=============================================================#=============================================================#二、循环结构分类：WHILE, LOOP, REPEAT循环控制语句：ITERATE：类似于CONTINUE,结束本次循环，继续下一次LEAVE：类似于break，跳出循环应用位置：只用在begin end中对比：1、这3种循环都可以省略标签，但如果要想在循环体中添加循环控制语句（leave, iterate)则必须添加标签2、loop：用于实现简单的死循环while：先判断，后执行；循环体可以一次都不执行repeat：先执行，后判断；循环体无条件至少执行一次#1、while语法：【标签：】WHILE 循环条件 DO 循环体;END WHILE 【标签】;#=============================================================#2、loop语法：【标签：】LOOP 循环体;END LOOP 【标签】;可以用来模拟简单的死循环#=============================================================#3、repeat语法：【标签：】REPEAT 循环体;UNTIL 结束循环的条件END REPEAT 【标签】;#==============================================================##没有添加循环控制语句#案例1：批量插入，根据次数插入到admin表中多条记录USE girls$CREATE PROCEDURE pro_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 1; WHILE i &lt;= insertCount DO INSERT INTO admin(username, PASSWORD) VALUES(CONCAT('Rose',i), '666'); SET i = i+1; END WHILE;END $CALL pro_while1(100)$SELECT * FROM admin$##添加循环控制语句#添加leave#案例2：批量插入，根据次数插入到admin中多条记录，如果次数大于20则停止TRUNCATE TABLE admin$DROP PROCEDURE pro_while1$CREATE PROCEDURE pro_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 1; a:WHILE i &lt;= insertCount DO INSERT INTO admin(username, PASSWORD) VALUES(CONCAT('xiaohua',i), '0000'); IF i &gt;= 20 THEN LEAVE a; -- 循环控制语句必须要给循环起标签 END IF; SET i = i+1; END WHILE a;END$CALL pro_while1(100)$#添加iterate#案例3：批量插入，根据次数插入到admin中多条记录，只插入偶数次TRUNCATE TABLE admin$DROP PROCEDURE pro_while1$CREATE PROCEDURE pro_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 0; a:WHILE i &lt;= insertCount DO SET i = i + 1; IF MOD(i,2) &lt;&gt; 0 THEN ITERATE a; END IF; INSERT INTO admin(username, PASSWORD) VALUES(CONCAT('xiaohua',i), '0000'); END WHILE a;END$CALL pro_while1(100)$SELECT * FROM admin$#=========================================================================###案例/*创建一个表，字段包括：id 自增长content varchar(20)向该表中插入指定个数的，随机的字符串*/CREATE TABLE stringcontent( id INT PRIMARY KEY AUTO_INCREMENT, content VARCHAR(20));CREATE PROCEDURE test_randstr_insert(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 1; -- 定义一个循环变量，表示插入次数 DECLARE str VARCHAR(26) DEFAULT 'abcdefghijklmnopqrstuvwxyz'; -- 随机字符串产生源 DECLARE startindex INT DEFAULT 1; -- 代表随机字符串起始索引 DECLARE len INT DEFAULT 1; -- 随机字符串长度 WHILE i&lt;= insertCount DO SET len = FLOOR(RAND()*IF((20-startindex+1)&lt;0, -1*(20-startindex+1),(20-startindex+1))) + 1; SET startindex = FLOOR(RAND()*26) + 1; INSERT INTO stringcontent(content) VALUES(SUBSTR(str, startindex, len)); SET i = i + 1; END WHILE;END $CALL test_randstr_insert(10)$SELECT * FROM stringcontent$","link":"/2023/10/16/MySQL%E5%9F%BA%E7%A1%80/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/10/16/hello-world/"}],"tags":[{"name":"sql","slug":"sql","link":"/tags/sql/"}],"categories":[{"name":"Database","slug":"Database","link":"/categories/Database/"}]}